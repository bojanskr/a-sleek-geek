---
layout: post
title: Test Driven Development
date: 2015-03-12 21:57:11.000000000 +01:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- BESTPRACTICES
- DESIGN
- PRINCIPLES
- SOFTWARE
- TDD
tags: []
meta:
  _rest_api_published: '1'
  _rest_api_client_id: "-1"
  _wpas_skip_10664483: '1'
  _wpas_skip_10664478: '1'
  _wpas_skip_10664475: '1'
  _wpas_skip_10664490: '1'
  publicize_linkedin_url: ''
  _publicize_job_id: '48192167028'
  _publicize_done_external: a:2:{s:7:"twitter";a:1:{i:23158388;s:55:"https://twitter.com/bojanskr/status/1299111087032369152";}s:8:"facebook";a:1:{i:24824976;s:52:"https://facebook.com/109859327422450_159338532474529";}}
  _publicize_done_22258584: '1'
  _wpas_done_23158388: '1'
  publicize_twitter_user: bojanskr
  _publicize_done_22258588: '1'
  _wpas_done_23158396: '1'
  _publicize_done_23096508: '1'
  _wpas_done_24824976: '1'
  _import_session_id: 5f57b340a397b
  _import_original_post_id: '74'
  original_post_id: '1655'
  _wp_old_slug: '1655'
author:
  login: bojanskr
  email: bojanskr@gmail.com
  display_name: TehBoyan
  first_name: Bojan
  last_name: Skrchevski
permalink: "/2015/03/12/test-driven-development/"
---
<p><!-- wp:paragraph --></p>
<p>It is pretty hard writing an article on something that so many super cool authors have written books about. But, as I said it is my own experience learning and embracing TDD that I want to share here so that maybe I can help someone out there that can relate to this. And also I can always remind myself of the process I went through while learning it.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Bottom line is that nobody can teach you a programming approach like this by writing or making videos about it. They can only get you started and they can tell you why you should do it. The real power comes by you actually digging into it. The more you do it the more you master it and the more you can actually feel the benefits of it. I didn’t believe when people said it was addictive, in matter of fact I opposed to the whole idea. I was one of the people that thought this is a waste of time and that you can achieve more by just writing production code….and boy….was I wrong about it.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>We have to start somewhere, so why not at the very core of it. The unit test definition....</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:more --><br />
<!--more--><br />
<!-- /wp:more --></p>
<p><!-- wp:heading {"level":5} --></p>
<h5><b>Unit test definition:</b></h5>
<p><!-- /wp:heading --></p>
<p><!-- wp:paragraph --></p>
<p>A UNIT TEST confirms the functionality of a small UNIT or component in a larger system.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>What does this mean? Well, it means isolating a small part of the system to test its proper internal functionality (emphasize on the “internal”). This, as we will see later in the text can be achieved bytesting for expected output or verifying that a method from another module has been called, depending on the test type.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:heading {"level":4} --></p>
<h4><b> Why Unit Testing? </b></h4>
<p><!-- /wp:heading --></p>
<p><!-- wp:paragraph --></p>
<p>Developer testing is more than just confirming functionality. It is an alternate way of coding. It is a culture. It puts us in the shoes of the user of the unit/class. It is one of those things that eliminate the fear of changing and improving the code. Adds that extra level of safety that we’re not going to break something if we change it in the code because we have a suit of tests that will tell us if it still works or we broke it. The need for debugging is taken down to a minimum.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>It provides inspection at the point of creation…opposed to testing the functionality after the development has been completed (It can cost up to 500% more to fix a bug after it has been shipped than during development). This way we have far smaller cycles of development and testing that provides more “agile” approach i.e. you are more bulletproof to changes.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Some other test properties:</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:list --></p>
<ul>
<li>Higher quality (more tests - fewer defects)</li>
<li>Living documentation (specification of what the software can do under given circumstances)…. <b> TESTS ARE THE SPECS </b> …(we’ll come back more on this later).</li>
<li>Well-crafted code</li>
<li>Automatic regression harness (insurance that adding new features will not break something else in the system).</li>
</ul>
<p><!-- /wp:list --></p>
<p><!-- wp:paragraph --></p>
<p>And the list goes on and on....and on....</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:heading {"level":5} --></p>
<h5><b> Types of Unit Tests </b></h5>
<p><!-- /wp:heading --></p>
<p><!-- wp:paragraph --></p>
<p>- Testing for output value</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Example:</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:quote --></p>
<blockquote class="wp-block-quote"><p>Assert.AreEqual(expectedValue, testingValue)</p>
</blockquote>
<p><!-- /wp:quote --></p>
<p><!-- wp:paragraph --></p>
<p>- Testing if a method is being called</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Example:</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:quote --></p>
<blockquote class="wp-block-quote"><p>Mock.Verify()</p>
</blockquote>
<p><!-- /wp:quote --></p>
<p><!-- wp:heading {"level":5} --></p>
<h5><b> Greenfield vs. Brownfield </b></h5>
<p><!-- /wp:heading --></p>
<p><!-- wp:paragraph --></p>
<p>It is much easier to start TDD on Greenfield project because you can make it embrace decoupling unlike the Legacy systems which might have tight coupling and could be very hard to test.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>As far as brownfield projects are concerned there are many strategies that can be taken on these legacy systems so they can be tested like <a title="Characterization Test" href="http://en.wikipedia.org/wiki/Characterization_Test"><span style="background:white;color:#0b0080;font-family:'Arial', 'sans-serif';font-size:10pt;line-height:115%;">Characterization Tests </span></a> proposed by Michael Feathers in his book “Working Effectively with Legacy Code” .</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:heading {"level":5} --></p>
<h5><b> Testing Frameworks </b></h5>
<p><!-- /wp:heading --></p>
<p><!-- wp:paragraph --></p>
<p>Choose your testing framework wisely (explore NUnit, xUnit etc.)</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:heading {"level":5} --></p>
<h5><b> Test Driven Development </b></h5>
<p><!-- /wp:heading --></p>
<p><!-- wp:paragraph --></p>
<p>TDD is one of the many agile methodologies and XP (eXteme programming) that recently created a lot of buzz and is taking more and more interest on its own. Kent Beck, who is credited with having developed the technique, states that TDD encourages simple designs and inspires confidence. And I totally agree with that statement. Once again the more you use it the more you benefit from it.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Software is often shaped as it is created. That’s why it makes sense to create unit tests just before we implement a feature.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>A little bit of tests, a little bit of code, a little bit…and so on….Which in the end results in the Red-Green-Refactor routine for TDD.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:list {"ordered":true} --></p>
<ol>
<li>Create a failing test</li>
<li>Write only enough code that is sufficient for the code to pass</li>
<li>Refactor - Improve the internal implementation without changing the external behaviour</li>
</ol>
<p><!-- /wp:list --></p>
<p><!-- wp:paragraph --></p>
<p>You should end up with just enough code and design to make what you’re doing work. I guess this raises the question of overworking things and designing big up front. This principle is exactly what opposes that.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:heading {"level":6} --></p>
<h6><b> Important questions: </b></h6>
<p><!-- /wp:heading --></p>
<p><!-- wp:quote --></p>
<blockquote class="wp-block-quote"><p>What tests to write?</p>
</blockquote>
<p><!-- /wp:quote --></p>
<p><!-- wp:paragraph --></p>
<p>Same thinking when creating a class or a set of classes to achieve but from a different view.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>One needs to look at starting of work as what do you expect this class or group of classes to do? What is the CORRECT input, and what is the CORRECT output.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:quote --></p>
<blockquote class="wp-block-quote"><p>Where to start?</p>
</blockquote>
<p><!-- /wp:quote --></p>
<p><!-- wp:paragraph --></p>
<p>Think like a client/user of a class.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Start by creating a test project and another project for the SUT.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Think about what do you want to do? Do we want a class, a set of classes, how are they achieving what they are supposed to do? Then we start writing test cases for valid and invalid input and test for valid or expected output.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Write tests for the more obvious cases first, cases that work, the main way the system will be used. Then work your way to the more specific side cases and handling invalid input.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:quote --></p>
<blockquote class="wp-block-quote"><p>·What does “Good suit of tests mean”?</p>
</blockquote>
<p><!-- /wp:quote --></p>
<p><!-- wp:paragraph --></p>
<p>Not only testing for coverage but covering all the valid and invalid cases that the SUT is supposed to work with, and testing for expected results, thus making sure that they SUT is working correctly.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:quote --></p>
<blockquote class="wp-block-quote"><p>How do I write unit tests?</p>
</blockquote>
<p><!-- /wp:quote --></p>
<p><!-- wp:paragraph --></p>
<p>Arrange, Act, Assert.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>As Kent Beck says… if you don’t know how to write the test write the line of code that will actually test the SUT, then work your way up to making the test work.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:heading {"level":5} --></p>
<h5><b> Maintenance of unit test code </b></h5>
<p><!-- /wp:heading --></p>
<p><!-- wp:paragraph --></p>
<p>Test code is just as important as production code. They are mutually testing each other. Test code is maintaining the production code but the production code is maintaining the tests (Uncle Bob’s analogy of double entry bookkeeping). Tests should be organized hierarchically as classes and treated as though they are the production code itself. We need to keep the test code maintainable and DRY.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>When you get new requirements and need to add new features, and your cod changes, the tests get updated too. This can cause the test code to become clumsy. We need to maintain it in order to be able to expand on it later.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:heading {"level":5} --></p>
<h5><b> Test qualities </b></h5>
<p><!-- /wp:heading --></p>
<p><!-- wp:paragraph --></p>
<p>· Repeatable – can be run at any time</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>· Independent – should run in any order</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:heading {"level":5} --></p>
<h5><b> Unit Test Organization </b></h5>
<p><!-- /wp:heading --></p>
<p><!-- wp:paragraph --></p>
<p>· Happy path (Does the system behave as we expect in with normal input values)</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>· Sad path(test for expected exceptions and behavior if illegal input is provided)</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>These two test approaches can be separated in to two separate test classes.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:heading {"level":5} --></p>
<h5><b> Refactoring </b></h5>
<p><!-- /wp:heading --></p>
<p><!-- wp:paragraph --></p>
<p>Why bother refactoring?</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>- To improve the quality of the code(better, faster): Readability, Maintainability, Scalability, Extensibility</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>- Because we always tend to write better code. Something that is done in code is never finished, it can always be improved. We should always tend to leave the systems better than we found it.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>- TDD can be seen as a “Clean as you go approach” with refactoring step being the cleaning</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>What is the definition of DONE?</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>- Done is not simply delivering the product and passing a set of failing unit tests. It is also cleaning after you’re done</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Skipping steps in favor of a deadline implies <b>TECHNICAL DEBT </b> . It is the same as a money debt. We sacrifice some of the system properties to meet a deadline etc.This later comes as interest in form of code rot etc.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Refactoring is the operation we perform to pay off that debt.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>We will explore much more test driven things in the future.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Until then...Happy coding.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>//Bojan</p>
<p><!-- /wp:paragraph --></p>
